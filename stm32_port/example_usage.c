/**
 * @file example_usage.c
 * @brief STM32 HAL库通信适配层使用示例
 * @author Generated by Cline
 * @date 2026-01-18
 */

#include "comm_stm32_hal_middle.h"
#include "comm.h"  // 原有的通信模块
#include "dataFrame.h"

// 外部UART句柄（由STM32 CubeMX生成）
extern UART_HandleTypeDef huart1;

// 通信句柄
static CommHandle_t* g_comm_handle = NULL;

/**
 * @brief 错误数据包回调函数
 * @param type 错误类型
 */
void comm_error_callback(uint32_t type)
{
    switch(type) {
        case 1:
            printf("通信错误：包头错误\r\n");
            break;
        case 2:
            printf("通信错误：校验和错误\r\n");
            break;
        default:
            printf("通信错误：未知错误类型 %lu\r\n", type);
            break;
    }
}

/**
 * @brief 遥控器数据接收回调函数
 * @param src 接收到的数据
 * @param size 数据长度
 * @param user_data 用户数据
 */
void rocker_data_recv_callback(uint8_t *src, uint16_t size, void* user_data)
{
    if (size >= sizeof(PackControl_t)) {
        PackControl_t* control_data = (PackControl_t*)src;
        
        printf("接收到遥控器数据:\r\n");
        printf("  摇杆1: X=%.2f, Y=%.2f\r\n", control_data->rocker[0], control_data->rocker[1]);
        printf("  摇杆2: X=%.2f, Y=%.2f\r\n", control_data->rocker[2], control_data->rocker[3]);
        printf("  按键状态: 0x%08lX\r\n", control_data->Key);
    }
}

/**
 * @brief HAL库UART发送完成中断回调函数
 * @param huart UART句柄
 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
    // 调用通信模块的发送完成中断处理函数
    if (g_comm_handle != NULL) {
        Comm_UART_TxCplt_IRQ_Handle(g_comm_handle, huart);
    }
}

/**
 * @brief 多线程发送测试任务1
 * @param pvParameters 任务参数
 */
void TestTask1(void *pvParameters)
{
    CommHandle_t* comm_handle = (CommHandle_t*)pvParameters;
    uint8_t counter = 0;
    
    while (1) {
        char msg[32];
        snprintf(msg, sizeof(msg), "Task1: %d\r\n", counter++);
        
        // 立即返回，不等待发送完成
        Comm_Write(comm_handle, (uint8_t*)msg, strlen(msg));
        
        vTaskDelay(pdMS_TO_TICKS(1000)); // 1秒发送一次
    }
}

/**
 * @brief 多线程发送测试任务2
 * @param pvParameters 任务参数
 */
void TestTask2(void *pvParameters)
{
    CommHandle_t* comm_handle = (CommHandle_t*)pvParameters;
    uint8_t counter = 0;
    
    while (1) {
        char msg[32];
        snprintf(msg, sizeof(msg), "Task2: %d\r\n", counter++);
        
        // 立即返回，不等待发送完成
        Comm_Write(comm_handle, (uint8_t*)msg, strlen(msg));
        
        vTaskDelay(pdMS_TO_TICKS(800)); // 0.8秒发送一次
    }
}

/**
 * @brief 测试任务（原有的）
 * @param pvParameters 任务参数
 */
void TestTask(void *pvParameters)
{
    CommHandle_t* comm_handle = (CommHandle_t*)pvParameters;
    uint8_t test_data[] = "Hello STM32 HAL UART!\r\n";
    
    while (1) {
        // 发送测试数据
        Comm_Write(comm_handle, test_data, sizeof(test_data) - 1);
        
        vTaskDelay(pdMS_TO_TICKS(2000)); // 2秒发送一次
    }
}

/**
 * @brief 初始化通信模块
 * @return 0-成功，-1-失败
 */
int comm_system_init(void)
{
    // 1. 初始化适配层
    g_comm_handle = Comm_Init(&huart1);
    if (g_comm_handle == NULL) {
        printf("通信适配层初始化失败\r\n");
        return -1;
    }
    
    // 2. 初始化原有通信模块
    RemoteCommInit(comm_error_callback);
    
    // 3. 注册接收回调
    uint32_t cb_id = register_comm_recv_cb(rocker_data_recv_callback, 
                                          CMD_REMOTE_UPDATE_ROCKER, 
                                          NULL);
    if (cb_id == 0) {
        printf("注册接收回调失败\r\n");
        return -1;
    }
    
    printf("通信系统初始化成功，回调ID: %lu\r\n", cb_id);
    return 0;
}

/**
 * @brief 发送反馈消息示例
 * @param message 要发送的消息
 * @return 0-成功，-1-失败
 */
int send_feedback_message(const char* message)
{
    PackMsg_t msg_pack;
    msg_pack.type = 1;  // 消息类型
    msg_pack.size = strlen(message);
    msg_pack.str = (char*)message;
    
    // 使用异步发送（不需要ACK确认）
    uint32_t result = asyn_comm_send_pack_nak((uint8_t*)&msg_pack, 
                                             PACK_STR_FEEDBACK_CMD, 
                                             sizeof(PackMsg_t));
    
    if (result) {
        printf("反馈消息已发送: %s\r\n", message);
        return 0;
    } else {
        printf("反馈消息发送失败\r\n");
        return -1;
    }
}

/**
 * @brief 发送控制数据示例（带ACK确认）
 * @param control_data 控制数据
 * @return 0-成功，-1-失败
 */
int send_control_data_with_ack(PackControl_t* control_data)
{
    if (control_data == NULL) {
        return -1;
    }
    
    // 使用同步发送（需要ACK确认）
    uint32_t result = comm_send_pack_ack((uint8_t*)control_data,
                                        PACK_CONTROL_CMD,
                                        sizeof(PackControl_t),
                                        1000,  // 超时时间1秒
                                        3);    // 最大重试3次
    
    if (result) {
        printf("控制数据发送成功\r\n");
        return 0;
    } else {
        printf("控制数据发送失败或超时\r\n");
        return -1;
    }
}

/**
 * @brief 发送完成回调函数
 * @param result 发送结果
 * @param user_data 用户数据
 */
void send_complete_callback(uint32_t result, void* user_data)
{
    if (result) {
        printf("异步发送完成：成功\r\n");
    } else {
        printf("异步发送完成：失败\r\n");
    }
}

/**
 * @brief 发送控制数据示例（异步带ACK确认）
 * @param control_data 控制数据
 * @return 0-成功，-1-失败
 */
int send_control_data_async_ack(PackControl_t* control_data)
{
    if (control_data == NULL) {
        return -1;
    }
    
    // 使用异步发送（带ACK确认和回调）
    uint32_t result = asyn_comm_send_pack_ack((uint8_t*)control_data,
                                             PACK_CONTROL_CMD,
                                             sizeof(PackControl_t),
                                             send_complete_callback,
                                             NULL,  // 用户数据
                                             3);    // 最大重试3次
    
    if (result) {
        printf("控制数据已提交发送队列\r\n");
        return 0;
    } else {
        printf("控制数据提交发送队列失败\r\n");
        return -1;
    }
}

/**
 * @brief 主循环示例
 */
void comm_main_loop_example(void)
{
    // 初始化通信系统
    if (comm_system_init() != 0) {
        printf("通信系统初始化失败\r\n");
        return;
    }
    
    // 示例：发送一条反馈消息
    send_feedback_message("STM32通信系统已启动");
    
    // 示例：创建并发送控制数据
    PackControl_t control_data = {
        .rocker = {0.5f, -0.3f, 0.8f, 0.1f},  // 摇杆数据
        .Key = Left_Key_Up | Right_Key_Down    // 按键状态
    };
    
    // 发送控制数据（同步方式）
    send_control_data_with_ack(&control_data);
    
    // 主循环
    while (1) {
        // 其他业务逻辑
        HAL_Delay(100);
        
        // 可以在这里处理其他任务
        // 通信接收是通过中断和任务自动处理的
    }
}
